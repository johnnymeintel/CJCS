Get-Process | Where-Object {$_.Company -ne "Microsoft Corporation" -and $_.ProcessName -ne "Idle" -and $_.ProcessName -ne "System"} | Select-Object Name,Id,CPU,WorkingSet,Path,Company | Sort-Object CPU -Descending   # list non-Microsoft processes sorted by CPU (third-party process inventory)
Get-NetTCPConnection | Where-Object {$_.State -eq "Listen"} | ForEach-Object { $Process = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue; [PSCustomObject]@{ LocalPort = $_.LocalPort; ProcessName = $Process.ProcessName; ProcessPath = $Process.Path; ProcessCompany = $Process.Company } } | Sort-Object LocalPort   # map listening TCP ports to process name/path/company (attack-surface view)
$procByPid = Get-CimInstance Win32_Process | Group-Object -Property ProcessId -AsHashTable -AsString   # build PID→process lookup table for fast correlation
Get-NetTCPConnection -State Listen | Sort-Object LocalPort | ForEach-Object { $p = $procByPid[[string]$_.OwningProcess]; [PSCustomObject]@{ LocalAddress = $_.LocalAddress; LocalPort = $_.LocalPort; PID = $_.OwningProcess; ProcessName = $p.Name; ExecutablePath = $p.ExecutablePath } }   # efficient port→process table using CIM cache (reduces repeated Get-Process calls)
Get-WmiObject Win32_Service | Where-Object {$_.StartName -notlike "*LocalSystem*" -and $_.StartName -notlike "*LocalService*" -and $_.StartName -notlike "*NetworkService*"} | Select-Object Name,StartName,State,PathName   # enumerate services running under explicit user accounts (privilege/persistence risk)
Get-CimInstance Win32_StartupCommand | Select-Object Name,Command,Location,User   # enumerate autostart entries (common persistence locations)
